# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m1hn6uA73MFuB2xrs8Ps6-Ca8seXALDJ
"""

#Taller 4 - Grupo 5

import numpy as np
import matplotlib.pyplot as plt

#1.a

def g_x(x, n=10, alpha=4/5):
    return sum(np.exp(-(x - k)**2 * k) / k**alpha for k in range(1, n+1))

def metropolis(f, x0, n, sigma):
    """Genera una cadena de Markov usando el algoritmo de Metropolis-Hastings."""
    samples = np.zeros(n)
    samples[0] = x0
    for i in range(1, n):
        sample_new = samples[i-1] + np.random.normal(0, sigma)
        if np.random.rand() < f(sample_new) / f(samples[i-1]):
            samples[i] = sample_new
        else:
            samples[i] = samples[i-1]
    return samples

# Generar muestras
samples = metropolis(lambda x: g_x(x), x0=5, n=500000, sigma=1.0)

# Crear histograma
plt.figure(figsize=(8,6))
plt.hist(samples, bins=200, density=True, alpha=0.6, color='b')
plt.xlabel("x")
plt.ylabel("Frecuencia")
plt.title("Histograma de muestras generadas con Metropolis-Hastings")
plt.savefig("1.a.pdf")

#1.b

def g_x_norm(x, n=10, alpha=4/5):
    return sum(np.exp(-(x - k)**2 * k) / k**(alpha + 1/2) for k in range(1, n+1))

def f_x(x):
    return np.exp(-x**2)

f_over_g = f_x(samples) / g_x_norm(samples)
A = np.sqrt(np.pi) / np.mean(f_over_g)
std_A = (np.sqrt(np.pi) / np.sqrt(len(samples))) * np.std(f_over_g)

# Imprimir resultado
print(f"1.b) A = {A} Â± {std_A}")