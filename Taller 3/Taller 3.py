# -*- coding: utf-8 -*-
"""Taller ODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kkVm3oyvS_orXCgMJCttJrQhBpE5QpSW
"""

# TALLER 3
# 1. BALÍSTICA -----------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar

# Parámetros del problema
m = 10  # masa (kg)
v0 = 10  # velocidad inicial (m/s)
g = 9.773  # gravedad en Bogotá (m/s²)
beta_vals = np.logspace(-3, np.log10(2), 50)  # Valores de β en escala logarítmica

# Parámetros de la simulación
dt = 0.001  # Paso de tiempo
t_max = 10   # Tiempo máximo de simulación

def simulacion_verlet(theta, beta):
    """Simula la trayectoria usando Verlet Velocity."""
    x, y = 0.0, 0.0
    vx = v0 * np.cos(np.radians(theta))
    vy = v0 * np.sin(np.radians(theta))
    posiciones_x, posiciones_y = [x], [y]

    while y >= 0:
        v = np.sqrt(vx**2 + vy**2)
        ax = -beta * v * vx / m
        ay = -g - beta * v * vy / m

        vx_mid = vx + ax * (dt / 2)
        vy_mid = vy + ay * (dt / 2)
        x += vx_mid * dt
        y += vy_mid * dt

        v = np.sqrt(vx_mid**2 + vy_mid**2)
        ax = -beta * v * vx_mid / m
        ay = -g - beta * v * vy_mid / m

        vx += ax * dt
        vy += ay * dt

        posiciones_x.append(x)
        posiciones_y.append(y)

    return np.array(posiciones_x), np.array(posiciones_y), vx, vy

def calcular_alcance_maximo(beta):
    """Encuentra el ángulo que maximiza el alcance con optimización."""
    def alcance_negativo(theta):
        x_final, _, _, _ = simulacion_verlet(theta, beta)
        return -max(x_final)  # Maximizar el alcance minimizando su negativo

    resultado = minimize_scalar(alcance_negativo, bounds=(10, 80), method='bounded')
    return resultado.x if resultado.success else 45

theta_max_list, energia_perdida_list = [], []

for beta in beta_vals:
    theta_max = calcular_alcance_maximo(beta)
    theta_max_list.append(theta_max)

    # Energía inicial
    E0 = 0.5 * m * v0**2

    # Energía final
    _, _, vx_f, vy_f = simulacion_verlet(theta_max, beta)
    vf = np.sqrt(vx_f**2 + vy_f**2)
    Ef = 0.5 * m * vf**2

    # Pérdida de energía
    delta_E = E0 - Ef
    energia_perdida_list.append(delta_E)

# Graficar θxmax vs β
plt.figure(figsize=(8, 6))
plt.plot(beta_vals, theta_max_list, marker='o', linestyle='-', color='b')
plt.xscale("log")
plt.xlabel(r"Coeficiente de fricción $\beta$ (kg/m)")
plt.ylabel(r"Ángulo de alcance máximo $\theta_{xmax}$ (°)")
plt.title(r"$\theta_{xmax}$ vs $\beta$")
plt.grid(True, which="both", linestyle="--")
plt.savefig("1.a.pdf")

# Graficar ΔE vs β
plt.figure(figsize=(8, 6))
plt.plot(beta_vals, energia_perdida_list, marker='s', linestyle='-', color='r')
plt.xscale("log")
plt.xlabel(r"Coeficiente de fricción $\beta$ (kg/m)")
plt.ylabel(r"Pérdida de energía $\Delta E$ (J)")
plt.title(r"$\Delta E$ vs $\beta$")
plt.grid(True, which="both", linestyle="--")
plt.savefig("1.b.pdf")

# 2. PARADOJA EN LA FÍSICA CLÁSICA ---------------------------------------------
from scipy.integrate import solve_ivp

# Constantes
a0 = 1  # Radio de Bohr en unidades atómicas
e = 1  # Carga del electrón en unidades atómicas
m_e = 1  # Masa del electrón en unidades atómicas
hbar = 1  # Constante de Planck reducida en unidades atómicas
alpha = 1 / 137.035999206  # Constante de estructura fina
c = 1 / alpha  # Velocidad de la luz en unidades atómicas

# Fuerza de Coulomb
def coulomb_force(t, y):
    x, vx, y_pos, vy = y
    r = np.sqrt(x**2 + y_pos**2)
    ax = -x / r**3
    ay = -y_pos / r**3
    return [vx, ax, vy, ay]

# Simulación sin Larmor
T_max = 20  # Tiempo máximo de simulación
dt = 0.01  # Paso de tiempo

# Condiciones iniciales
x0, y0 = 1, 0
vx0, vy0 = 0, 1
y_init = [x0, vx0, y0, vy0]

# Resolver ecuaciones de movimiento sin Larmor
sol = solve_ivp(coulomb_force, [0, T_max], y_init, method='RK45', t_eval=np.arange(0, T_max, dt))

# Período teórico con la tercera ley de Kepler
P_teo = 2 * np.pi  # En unidades atómicas

# Encontrar período de la simulación
zero_crossings = np.where(np.diff(np.sign(sol.y[1])))[0]  # Cruces de velocidad en x
P_sim = 2 * np.mean(np.diff(sol.t[zero_crossings])) if len(zero_crossings) > 1 else np.nan

print(f"2.a) P_teo = {P_teo:.5f}; P_sim = {P_sim:.5f}")

# Diagnóstico: energía total y radio en función del tiempo
"""
plt.figure()
plt.subplot(2, 1, 1)
plt.plot(sol.t, 0.5 * (sol.y[1]**2 + sol.y[3]**2) - 1 / np.sqrt(sol.y[0]**2 + sol.y[2]**2))
plt.ylabel("Energía total")

plt.subplot(2, 1, 2)
plt.plot(sol.t, np.sqrt(sol.y[0]**2 + sol.y[2]**2))
plt.ylabel("Radio")
plt.xlabel("Tiempo (unidades atómicas)")

plt.savefig("2.a.diagnostics.pdf")
"""

# Simulación con pérdida por Larmor
def motion_with_larmor(t, y):
    x, vx, y_pos, vy = y
    r = np.sqrt(x**2 + y_pos**2)
    ax = -x / r**3
    ay = -y_pos / r**3
    return [vx, ax, vy, ay]

def apply_larmor_correction(y, dt):
    vx, vy = y[1], y[3]
    ax, ay = -y[0] / (y[0]**2 + y[2]**2)**(3/2), -y[2] / (y[0]**2 + y[2]**2)**(3/2)
    a2 = ax**2 + ay**2
    v2 = vx**2 + vy**2
    dv2 = (4/3) * a2 * alpha**3 * dt
    if v2 > dv2:
        factor = np.sqrt((v2 - dv2) / v2)
        y[1] *= factor
        y[3] *= factor
    else:
        y[1], y[3] = 0, 0
    return y

# Simulación con integración por pasos para incluir Larmor
sol_larmor = [y_init]
time = [0]
t = 0
y = np.array(y_init)
while t < T_max and np.sqrt(y[0]**2 + y[2]**2) > 0.01:
    sol_step = solve_ivp(motion_with_larmor, [t, t + dt], y, method='RK45')
    y = sol_step.y[:, -1]
    y = apply_larmor_correction(y, dt)
    sol_larmor.append(y)
    t += dt
    time.append(t)

sol_larmor = np.array(sol_larmor).T

# Encontrar tiempo de caída
distances = np.sqrt(sol_larmor[0]**2 + sol_larmor[2]**2)
fall_indices = np.where(distances < 0.1)[0]
t_fall = time[fall_indices[0]] if len(fall_indices) > 0 else np.nan

if np.isnan(t_fall):
    print("2.b) El electrón no cayó al núcleo en el tiempo de simulación.")
else:
    print(f"2.b) t_fall = {t_fall * 24.18884:.5f} as")  # Conversión a attosegundos

# Mostrar y guardar gráficas con los títulos intercambiados correctamente
"""
plt.figure()
plt.plot(sol_larmor[0], sol_larmor[2])
plt.xlabel("x (a0)")
plt.ylabel("y (a0)")
plt.title("Órbita sin pérdida por Larmor")  # Ahora correcto
plt.savefig("2.a.XY.pdf")
"""

plt.figure()
plt.plot(sol.y[0], sol.y[2])
plt.xlabel("x (a0)")
plt.ylabel("y (a0)")
plt.title("Órbita con pérdida por Larmor")  # Ahora correcto
plt.savefig("2.b.XY.pdf")

# Diagnóstico: energía y radio con pérdida por Larmor
plt.figure()
plt.subplot(3, 1, 1)
plt.plot(time, 0.5 * (sol_larmor[1]**2 + sol_larmor[3]**2) - 1 / np.sqrt(sol_larmor[0]**2 + sol_larmor[2]**2))
plt.ylabel("Energía total")

plt.subplot(3, 1, 2)
plt.plot(time, 0.5 * (sol_larmor[1]**2 + sol_larmor[3]**2))
plt.ylabel("Energía cinética")

plt.subplot(3, 1, 3)
plt.plot(time, np.sqrt(sol_larmor[0]**2 + sol_larmor[2]**2))
plt.ylabel("Radio")
plt.xlabel("Tiempo (unidades atómicas)")

plt.savefig("2.b.diagnostics.pdf")

